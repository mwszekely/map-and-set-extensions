{"version":3,"file":"index.js","sources":["../../src/bimap-exclusive.ts","../../src/bimap-mixed.ts","../../src/map-helpers.ts","../../src/map-of-sets.ts","../../src/recursive-map.ts"],"sourcesContent":["var _BimapExclusive_impl;\nimport { __classPrivateFieldGet } from \"tslib\";\n/**\n * A variant of a map that's a 1-1 mapping between key->value OR value->key. Can be used to represent certain types of Enums, for example.\n *\n * Unlike `BimapSeparate`, this assumes that the two keys are mutually exclusive and saves a bit of work by only having one `Map` instead of two.\n */\nexport class BimapExclusive {\n    constructor() {\n        _BimapExclusive_impl.set(this, new Map());\n    }\n    /**\n     * Adds a new value to this bimap, associating these two keys with one another.\n     */\n    add(left, right) {\n        console.assert(__classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").has(left) === __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").has(right), \"A key has been re-defined, which will likely lead to undefined behavior when iterating. If you need to change a mapping, delete it first.\");\n        try {\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").set(left, right);\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").set(right, left);\n        }\n        catch (ex) {\n            // Can `set` throw? Just in case...\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").delete(left);\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").delete(right);\n            throw ex;\n        }\n        return this;\n    }\n    delete(key) {\n        if (__classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").has(key)) {\n            let other = __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").get(key);\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").delete(key);\n            __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").delete(other);\n            return true;\n        }\n        return false;\n    }\n    has(key) {\n        return __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").has(key);\n    }\n    get(key) {\n        return __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").get(key);\n    }\n    clear() {\n        __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").clear();\n    }\n    *entries() {\n        // This assumes certain standardized things about insertion order and such,\n        // but it's this way to prevent duplicates.\n        let skip = false;\n        for (let [left, right] of __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\")) {\n            if (skip)\n                continue;\n            yield [left, right];\n            skip = !skip;\n        }\n    }\n    forEach(callbackfn) {\n        let entries = this.entries();\n        for (let [keyA, keyB] of entries) {\n            callbackfn(keyA, keyB, this);\n        }\n    }\n    // These contain duplicates. Is it guaranteed to ALWAYS be safe to return every other entry? Because that would work if it's allowed.\n    /*entries() {\n        return this.#impl.entries();\n    }\n\n    forEach(callbackfn: (keyLeft: KeyLeft, keyRight: KeyRight, bimap: Bimap<KeyLeft, KeyRight>) => void) {\n        return this.#impl.forEach((value, key, map) => { return callbackfn(key, value, this); })\n    }*/\n    get size() {\n        return __classPrivateFieldGet(this, _BimapExclusive_impl, \"f\").size / 2;\n    }\n}\n_BimapExclusive_impl = new WeakMap();\n//# sourceMappingURL=bimap-exclusive.js.map","var _BimapMixed_implLeft, _BimapMixed_implRight;\nimport { __classPrivateFieldGet } from \"tslib\";\n/**\n * A variant of a map that's a 1-1 mapping between key->value OR value->key. Can be used to represent certain types of Enums, for example.\n *\n * To differentiate, keys are either \"left\" or \"right\" keys with no preference between either (ideally. In practice left is slighly preferred in cases where `hint` is not passed).\n *\n * In some ways it's also like a set, so its methods are modeled after a set, with the addition of a `get` method to turn left into right and vice-versa.\n *\n * Unlike `BimapExclusive`, this allows overlap between the two key types, but gives slight preferential treatment to the left keys and incurs a slight performance penalty.\n */\nexport class BimapMixed {\n    constructor() {\n        _BimapMixed_implLeft.set(this, new Map());\n        _BimapMixed_implRight.set(this, new Map());\n    }\n    /**\n     * Adds a new value to this bimap, associating these two keys with one another.\n     */\n    add(left, right) {\n        __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").set(left, right);\n        __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").set(right, left);\n        return this;\n    }\n    delete(key, hint) {\n        let has = false;\n        let keyLeft;\n        let keyRight;\n        if (hint == 'left') {\n            keyLeft = key;\n            has = __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").has(keyLeft);\n            keyRight = __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").get(keyLeft);\n        }\n        else if (hint == 'right') {\n            keyRight = key;\n            has = __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").has(keyRight);\n            keyLeft = __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").get(keyRight);\n        }\n        else {\n            if (__classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").has(key)) {\n                keyLeft = key;\n                has = true;\n                keyRight = __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").get(keyLeft);\n            }\n            else if (__classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").has(key)) {\n                keyRight = key;\n                has = true;\n                keyLeft = __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").get(keyRight);\n            }\n        }\n        if (has) {\n            __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").delete(keyLeft);\n            __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").delete(keyRight);\n        }\n        return has;\n    }\n    has(key, hint) {\n        if (hint === 'left')\n            return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").has(key);\n        if (hint === 'right')\n            return __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").has(key);\n        return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").has(key) || __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").has(key);\n    }\n    get(key, hint) {\n        if (hint === 'left')\n            return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").get(key);\n        if (hint === 'right')\n            return __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").get(key);\n        if (this.has(key, \"left\"))\n            return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").get(key);\n        if (this.has(key, \"right\"))\n            return __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").get(key);\n        return undefined;\n    }\n    clear() {\n        __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").clear();\n        __classPrivateFieldGet(this, _BimapMixed_implRight, \"f\").clear();\n    }\n    entries() {\n        return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").entries();\n    }\n    forEach(callbackfn) {\n        return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").forEach((value, key) => { return callbackfn(key, value, this); });\n    }\n    get size() {\n        return __classPrivateFieldGet(this, _BimapMixed_implLeft, \"f\").size;\n    }\n}\n_BimapMixed_implLeft = new WeakMap(), _BimapMixed_implRight = new WeakMap();\n//# sourceMappingURL=bimap-mixed.js.map","export function modifyMapAt(map, key, fn) {\n    return map.set(key, fn(map.get(key)));\n}\nexport function mapGetRecursive(map, ...keys) {\n    const [firstKey, ...restKeys] = keys;\n    if (map.has(firstKey))\n        return mapGetRecursive(map.get(firstKey), ...restKeys);\n    return undefined;\n}\n//# sourceMappingURL=map-helpers.js.map","/**\n * Functions to handle the specialization of a `Map` whose values are always a `Set`.\n */\nexport const MapOfSets = {\n    add: (map, key, value) => {\n        var _a;\n        let set = (_a = map.get(key)) !== null && _a !== void 0 ? _a : new Set();\n        set.add(value);\n        map.set(key, set);\n        return map;\n    },\n    /**\n     * Removes this `value` from the `Set` associated with `key`. Does not remove the `Set` itself, even if it becomes empty.\n     */\n    delete: (map, key, value) => {\n        var _a;\n        let set = (_a = map.get(key)) !== null && _a !== void 0 ? _a : new Set();\n        let ret = set.delete(value);\n        map.set(key, set);\n        return ret;\n    },\n    has: (map, key, value) => {\n        var _a, _b;\n        return (_b = (_a = map.get(key)) === null || _a === void 0 ? void 0 : _a.has(value)) !== null && _b !== void 0 ? _b : false;\n    }\n};\n//# sourceMappingURL=map-of-sets.js.map","export const RecursiveMap = {\n    set: recursiveMapSet,\n    get: recursiveMapGet,\n    has: recursiveMapHas,\n    /**\n     * Like `set`, but takes a callback that allows you to modify a previous value, if any.\n     */\n    modify: recursiveMapModify,\n};\nfunction recursiveMapGet(map, ...keys) {\n    const [firstKey, ...restKeys] = keys;\n    if (restKeys.length === 0) {\n        return map.get(firstKey);\n    }\n    let subMap = map.get(firstKey);\n    if (subMap === undefined)\n        return undefined;\n    return recursiveMapGet(subMap, ...restKeys);\n}\nfunction recursiveMapHas(map, ...keys) {\n    const [firstKey, ...restKeys] = keys;\n    if (restKeys.length === 0) {\n        return map.has(firstKey);\n    }\n    let subMap = map.get(firstKey);\n    if (subMap === undefined)\n        return false;\n    return recursiveMapHas(subMap, ...restKeys);\n}\nfunction recursiveMapSet(map, ...keysAndValue) {\n    return recursiveMapModify(map, ...keysAndValue.slice(0, keysAndValue.length - 1), () => keysAndValue[keysAndValue.length - 1]);\n}\nfunction recursiveMapModify(map, ...keysAndValue) {\n    const [firstKey, ...restKeysAndValue] = keysAndValue;\n    if (restKeysAndValue.length == 1) {\n        let had = map.has(firstKey);\n        let prev = map.get(firstKey);\n        map.set(firstKey, restKeysAndValue[0](prev, had));\n    }\n    else {\n        let subMap = map.get(firstKey);\n        if (subMap == null) {\n            map.set(firstKey, subMap = new Map());\n        }\n        recursiveMapModify(subMap, ...restKeysAndValue);\n    }\n}\n//# sourceMappingURL=recursive-map.js.map"],"names":["__classPrivateFieldGet"],"mappings":"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"}